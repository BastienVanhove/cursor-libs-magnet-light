import{createAtom as E}from"../atoms";const o={key:"history"},r={key:"present"},A={key:"future"},F="`useHistoryAtom` can only be used with atoms from `historyAtom`",i=E({beforeValueSet:(e,t,s)=>{s&&(e.UNSAFE_storage.set(o,[]),e.UNSAFE_storage.set(A,[]));const n=e.UNSAFE_storage.get(o),u=e.UNSAFE_storage.get(r),g=[...n,u];e.UNSAFE_storage.set(o,g),e.UNSAFE_storage.set(r,t)},onCreate:e=>(e.undo=()=>{const t=e.UNSAFE_storage.get(o),s=t[t.length-1],n=t.slice(0,t.length-1),u=e.UNSAFE_storage.get(r),g=e.UNSAFE_storage.get(A),S=[u,...g];e.UNSAFE_storage.set(o,n),e.UNSAFE_storage.set(r,s),e.UNSAFE_storage.set(A,S),e.UNSAFE_directSet(s),e.UNSAFE_notify()},e.redo=()=>{const t=e.UNSAFE_storage.get(A),s=t[0],n=t.slice(1),u=e.UNSAFE_storage.get(r),S=[...e.UNSAFE_storage.get(o),u];e.UNSAFE_storage.set(A,n),e.UNSAFE_storage.set(r,s),e.UNSAFE_storage.set(o,S),e.UNSAFE_directSet(s),e.UNSAFE_notify()},e),onGet:e=>e.UNSAFE_storage.get(r)}),d=e=>{if((s=>"undo"in s&&"redo"in s)(e))return{undo:e.undo,redo:e.redo};throw new Error(F)};export{A as FUTURE_KEY,F as NOT_HISTORY_ATOM_ERROR,o as PAST_KEY,r as PRESENT_KEY,i as historyAtom,d as useHistoryAtom};
